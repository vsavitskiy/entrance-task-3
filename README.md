# Задание 3

Мобилизация.Гифки – сервис для поиска гифок в перерывах между занятиями.

Сервис написан с использованием [bem-components](https://ru.bem.info/platform/libs/bem-components/5.0.0/).

Работа избранного в оффлайне реализована с помощью технологии [Service Worker](https://developer.mozilla.org/ru/docs/Web/API/Service_Worker_API/Using_Service_Workers).

Для поиска изображений используется [API сервиса Giphy](https://github.com/Giphy/GiphyAPI).

В браузерах, не поддерживающих сервис-воркеры, приложение так же должно корректно работать, 
за исключением возможности работы в оффлайне.

## Структура проекта

  * `gifs.html` – точка входа
  * `assets` – статические файлы проекта
  * `vendor` –  статические файлы внешних библиотек
  * `service-worker.js` – скрипт сервис-воркера

Открывать `gifs.html` нужно с помощью локального веб-сервера – не как файл. 
Это можно сделать с помощью встроенного в WebStorm/Idea веб-сервера, с помощью простого сервера
из состава PHP или Python. Можно воспользоваться и любым другим способом.


## Решение

Первая проблема в том что сервис-воркер находится в директории `assets`. Поэтому он не может контролировать `gifs.html`
находящийся в корне проекта. Это особенность работы сервис-воркеров. Можно задать подконтрольную директорию при регистрации
сервис-воркера, но она обязательно должна находиться ниже в иерархии. Поэтому для начала перенесем `service-worker.js`
в корень проекта и изменим путь к нему в `blocks.js`

Теперь сервис-воркер начал кешировать статику (можно посмотреть в `chrome devtools` во вкладке `application`), но оффлайн не работает. Дело в том что функция `needStoreForOffline`
анализирует имя и/или путь к файлу и исходя из этого выбирает стратегию. `gifs.html` на данный момент попадает под стратегию
`fetchWithFallbackToCache` (попытаться взять файл из сети, если не выходит то взять из кеша). Так как подключения нет, и 
в кеш мы `gifs.html` не сохраняли то получаем ошибку при загрузке страницы в оффлайне. Добавим `gifs.html` в `needStoreForOffline`,
чтобы решить проблему. Было бы хорошо кешировать статику в `oninstall`, но это дополнительное задание, так что сделаю позже :) 

Оффлайн-режим заработал, однако осталась проблема с обновлением закешированных файлов. Проблема вот тут:

```
response = caches.match(cacheKey)
           .then(cacheResponse => cacheResponse || fetchAndPutToCache(cacheKey, event.request));
```

Однажды закешированный файл будет браться из кеша пока пользователь или браузер не очистит его (кеш). Лучше использовать
стратегию "Network-first". Изменим код:

```
response = fetchAndPutToCache(cacheKey, event.request);
```

На этом все :)


### Ответы на вопросы

##### Вопрос №1: зачем нужен этот вызов?

```
self.skipWaiting()
```
По умолчанию после установки сервис-воркера браузер ждет пока остальные клиенты контроллируемые сервис-воркером будут закрыты,
так как на этапе активации обычно удаляются старые кеши. Вызов `self.skipWaiting()` позволяет перейти к активации немедленно


##### Вопрос №2: зачем нужен этот вызов?
```
self.clients.claim();
```
Этот вызов нужен чтобы начать контроллировать клиентов без их перезагрузки


##### Вопрос №3: для всех ли случаев подойдёт такое построение ключа?
```
const cacheKey = url.origin + url.pathname;
```
Если надо закешировать GET-запросы с параметрами то такой ключ не подойдет, так как параметры в ключ не попадают


##### Вопрос №4: зачем нужна эта цепочка вызовов?
```
return Promise.all(
    names.filter(name => name !== CACHE_VERSION)
        .map(name => {
            console.log('[ServiceWorker] Deleting obsolete cache:', name);
            return caches.delete(name);
        })
);
```
`names.filter` Возвращает массив со всеми версиями кешей, которые не соответствуют текущей

`map` Берет каждый элемент массива и заменяет его промисом возвращенным вызовом `caches.delete`

`Promise.all` Возвращает промис который будет разрешен когда разрешатся все промисы из собранного массива

Проще говоря результат вернется когда удалятся все кеши не соответствующие этой версии. Синхронно мы это сделать не
можем потому что `caches.delete` как и весь api возвращает промисы



##### Вопрос №5: для чего нужно клонирование?
Объекты типов `Request` и `Response` это потоки. В `Request` можно писать один раз, а из `Response` можно читать только один раз.
Чтобы создать копию потока (например чтобы сохранить response в кеш, а затем вернуть) используется метод `clone`